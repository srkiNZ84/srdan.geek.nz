<!doctype html><html lang=en><head><title>Setting up Mutual TLS with Prometheus · Home of Srđan Đukić</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta http-equiv=content-security-policy content="upgrade-insecure-requests; block-all-mixed-content; default-src 'self'; child-src 'self'; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net/; form-action 'self'; frame-src 'self' https://disqus.com; img-src 'self' https://www.gravatar.com https://referrer.disqus.com https://c.disquscdn.com https://cdn.viglink.com; object-src 'none'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/ https://cdn.jsdelivr.net/ https://c.disquscdn.com; script-src 'self' 'unsafe-inline' https://www.google-analytics.com https://srdan-geek-nz.disqus.com https://c.disquscdn.com; prefetch-src 'self' https://c.disquscdn.com https://disqus.com; connect-src 'self' https://www.google-analytics.com https://links.services.disqus.com;"><meta name=author content="Srđan Đukić"><meta name=description content="Setting up mutual TLS between Prometheus and Node Exporter"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Setting up Mutual TLS with Prometheus"><meta name=twitter:description content="Setting up mutual TLS between Prometheus and Node Exporter"><meta property="og:title" content="Setting up Mutual TLS with Prometheus"><meta property="og:description" content="Setting up mutual TLS between Prometheus and Node Exporter"><meta property="og:type" content="article"><meta property="og:url" content="https://srdan.geek.nz/posts/friday-15th-july-22/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-14T16:48:56+12:00"><meta property="article:modified_time" content="2022-07-14T16:48:56+12:00"><link rel=canonical href=https://srdan.geek.nz/posts/friday-15th-july-22/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.36f76aaf39a14ecf5c3a3c6250dcaf06c238b3d8365d17d646f95cb1874e852b.css integrity="sha256-NvdqrzmhTs9cOjxiUNyvBsI4s9g2XRfWRvlcsYdOhSs=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Home of Srđan Đukić</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://srdan.geek.nz/posts/friday-15th-july-22/>Setting up Mutual TLS with Prometheus</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-07-14T16:48:56+12:00>July 14, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
4-minute read</span></div><div class=authors><i class="fa fa-user" aria-hidden=true></i>
<a href=/authors/sr%C4%91an-%C4%91uki%C4%87/>Srđan Đukić</a></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/prometheus/>prometheus</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/node-exporter/>node-exporter</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/tls/>tls</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/ssl/>ssl</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/mtls/>mTLS</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/authentication/>authentication</a></span></div></div></header><div class=post-content><h2 id=about>About
<a class=heading-link href=#about><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>So, recently I was tasked with trying to securely enable metrics collection from servers which did not have a
private/management IP, only a publicly routable IP address.</p><p>This was a challenge in that if we are going to expose metrics over the public internet, security becomes a much bigger
focus.</p><p>While it was tempting to rely on a single mechanism to restrict access (such as firewall rules to only allow connections
from the Prometheus server), experience has taught us that it&rsquo;s much better to not assume that any single mechanism will
work all the time (see: <a href=https://en.wikipedia.org/wiki/Swiss_cheese_model>Swiss Cheese Model</a>). Instead we should adopt
several security mecahnisms such that if a single one fails, others will pick it up (also called &ldquo;Defence in Depth&rdquo;).</p><p>In that spirit, I started looking at other authentication and authorization mechanisms for Prometheus Node exporter and
came to the conclusion that client TLS certificates (also called mutual TLS) are probably the best way to go security
wise (you get encryption to mitigate MITM attacks, along with authentication/authorization to prevent unauthorized access
to the endpoint). You also don&rsquo;t have to worry about passwords not being long enough/complicated enough as the client
certificate has more than enough entropy.</p><h2 id=how-prometheus-mutual-tls-works>How Prometheus mutual TLS works
<a class=heading-link href=#how-prometheus-mutual-tls-works><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>At a high level, we want to achieve two things:</p><ul><li>Have the HTTP interface (the one we access through the browser) to the Prometheus server enable TLS (HTTPS)</li><li>Have the HTTP interface (the one that Prometheus accesses programatically) on our Node Exporters require TLS <em>and</em> a
valid client certificate (i.e. signed by our internal CA)</li></ul><h2 id=setting-up-tls-on-the-prometheus-server>Setting up TLS on the Prometheus server
<a class=heading-link href=#setting-up-tls-on-the-prometheus-server><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The first step is to generate a CA and certificates for the Prometheus server and the Node exporter and sign them all.
This is described in a previous blog post <a href=https://srdan.geek.nz/posts/thursday-14th-july-22/>here</a>. At the end of it,
we are left with three sets of files:</p><ul><li>ca-key.pem (CA private key)</li><li>ca.pem (CA certificate, used for signing)</li><li>prom.key (Prometheus private key)</li><li>prom.pem (Prometheus certificate, signed by the CA)</li><li>prom-ne-key.pem (Node Exporter private key)</li><li>prom-ne.pem (Node Exporter certificate, signed by the CA)</li></ul><p>Next we need to modify the Prometheus server to use the web config file where our TLS configuration is going to go. On
Ubuntu 22.04, this means adding the <code>--web-config argument</code> to the <code>/etc/default/prometheus</code> file:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ARGS=&#34;--web.config.file=/etc/prometheus/web-config.yml&#34;
</span></span></code></pre></div><p>The contents of the <code>web-config.yml</code> file are as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>tls_server_config:
</span></span><span style=display:flex><span>  cert_file: prom.pem
</span></span><span style=display:flex><span>  key_file: prom-key.pem
</span></span><span style=display:flex><span>  client_ca_file: ca.pem
</span></span><span style=display:flex><span>  client_auth_type: VerifyClientCertIfGiven
</span></span></code></pre></div><p>Once these changes have been made, we can restart the Prometheus server with <code>systemctl restart prometheus</code> which should
pick up the new configuration. We can verify it has started correctly with <code>systemctl status prometheus</code> or <code>journalctl -f -u prometheus</code>.</p><p>If it has started correctly, we can now verify that the TLS is working by checking that we are unable to access the
Prometheus Web interface over plain HTTP, but HTTPS is working (i.e. <code>http://localhost:9090/</code> gives an error
but <code>https://localhost:9090/</code> does not)</p><p>NOTE: In the example we are using a self signed CA that we generated, so the browser will likely complain about the
hostname not matching the certificate</p><h2 id=setting-up-tls-on-the-node-exporter>Setting up TLS on the Node exporter
<a class=heading-link href=#setting-up-tls-on-the-node-exporter><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>For the Node exporter, we want to configure it to point to our web configuration file by modifying
<code>/etc/default/prometheus-node-exporter</code> to ensure it has the line:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ARGS=&#34;--web.config=/etc/prometheus/node-exporter-web-config.yml&#34;
</span></span></code></pre></div><p>with the contents of the file being as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>tls_server_config:
</span></span><span style=display:flex><span>  cert_file: prom-ne.pem
</span></span><span style=display:flex><span>  key_file: prom-ne-key.pem
</span></span><span style=display:flex><span>  client_ca_file: ca.pem
</span></span><span style=display:flex><span>    #client_auth_type: RequestClientCert
</span></span><span style=display:flex><span>  client_auth_type: RequireAndVerifyClientCert
</span></span></code></pre></div><p>We can now go ahead and restart the Node Exporter server and verify that it starts up correctly and is serving over TLS
the same as above.</p><p>Now we need to add Node Exporter to the scrape configs, specifying that it should pick up and use the client certificate
when connecting. In <code>/etc/prometheus/prometheus.yml</code> we add the following section (replace static configuration with
whatever is appropriate):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>scrape_configs:
</span></span><span style=display:flex><span>  - job_name: node
</span></span><span style=display:flex><span>    # If prometheus-node-exporter is installed, grab stats about the local
</span></span><span style=display:flex><span>    # machine by default.
</span></span><span style=display:flex><span>    scheme: &#39;https&#39;
</span></span><span style=display:flex><span>    tls_config:
</span></span><span style=display:flex><span>      ca_file: &#39;ca.pem&#39;
</span></span><span style=display:flex><span>      cert_file: &#39;prom.pem&#39;
</span></span><span style=display:flex><span>      key_file: &#39;prom-key.pem&#39;
</span></span><span style=display:flex><span>    static_configs:
</span></span><span style=display:flex><span>      - targets: [&#39;127.0.0.1:9100&#39;]
</span></span></code></pre></div><p>We can then verify whether this is working or not by navigating to the &ldquo;Targets&rdquo; section in the Prometheus server Web UI
(i.e. https://localhost:9090/classic/targets) and confirming that there are no errors scraping the Node Exporter
metrics.</p><h2 id=further-work>Further work
<a class=heading-link href=#further-work><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The above was a good setup, but needs to be tested with public facing IP&rsquo;s and hostname&rsquo;s. Especially it would be
interesting to see whether there is any checking of the client hostname when the certificate is presented.</p><p>It would also be interesting whether we could add Basic Authentication in addition to mTLS on the endpoints, so that
anyone connecting requires both the certificate and the password.</p><h2 id=references>References
<a class=heading-link href=#references><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><a href=https://pkg.go.dev/crypto/tls>https://pkg.go.dev/crypto/tls</a></p><p><a href=https://prometheus.io/docs/prometheus/latest/configuration/https/>https://prometheus.io/docs/prometheus/latest/configuration/https/</a></p><p><a href=https://prometheus.io/docs/prometheus/latest/configuration/configuration/#tls_config>https://prometheus.io/docs/prometheus/latest/configuration/configuration/#tls_config</a></p></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//srdan-geek-nz.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
Srđan Đukić
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>